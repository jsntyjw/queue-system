{"ast":null,"code":"import { statSync, createReadStream, promises as fs } from 'node:fs';\nimport { basename } from 'node:path';\nimport DOMException from 'node-domexception';\nimport File from './file.js';\nimport Blob from './index.js';\nconst {\n  stat\n} = fs;\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\n\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type);\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\n\n\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\n\n\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type));\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\n\n\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type); // @ts-ignore\n\n\nconst fromBlob = function (stat, path) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return new Blob([new BlobDataItem({\n    path,\n    size: stat.size,\n    lastModified: stat.mtimeMs,\n    start: 0\n  })], {\n    type\n  });\n}; // @ts-ignore\n\n\nconst fromFile = function (stat, path) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return new File([new BlobDataItem({\n    path,\n    size: stat.size,\n    lastModified: stat.mtimeMs,\n    start: 0\n  })], basename(path), {\n    type,\n    lastModified: stat.mtimeMs\n  });\n};\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\n\n\nclass BlobDataItem {\n  #path;\n  #start;\n\n  constructor(options) {\n    this.#path = options.path;\n    this.#start = options.start;\n    this.size = options.size;\n    this.lastModified = options.lastModified;\n  }\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n\n\n  slice(start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    });\n  }\n\n  async *stream() {\n    const {\n      mtimeMs\n    } = await stat(this.#path);\n\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError');\n    }\n\n    yield* createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n\n}\n\nexport default blobFromSync;\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync };","map":null,"metadata":{},"sourceType":"module"}