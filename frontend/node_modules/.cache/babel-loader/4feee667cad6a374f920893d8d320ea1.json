{"ast":null,"code":"/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\nimport { types } from 'node:util';\nimport http from 'node:http';\n/* c8 ignore next 9 */\n\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ? http.validateHeaderName : name => {\n  if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n    Object.defineProperty(error, 'code', {\n      value: 'ERR_INVALID_HTTP_TOKEN'\n    });\n    throw error;\n  }\n};\n/* c8 ignore next 9 */\n\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ? http.validateHeaderValue : (name, value) => {\n  if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n    const error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n    Object.defineProperty(error, 'code', {\n      value: 'ERR_INVALID_CHAR'\n    });\n    throw error;\n  }\n};\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\n\nexport default class Headers extends URLSearchParams {\n  /**\n   * Headers class\n   *\n   * @constructor\n   * @param {HeadersInit} [init] - Response headers\n   */\n  constructor(init) {\n    // Validate and normalize init object in [name, value(s)][]\n\n    /** @type {string[][]} */\n    let result = [];\n\n    if (init instanceof Headers) {\n      const raw = init.raw();\n\n      for (const [name, values] of Object.entries(raw)) {\n        result.push(...values.map(value => [name, value]));\n      }\n    } else if (init == null) {// eslint-disable-line no-eq-null, eqeqeq\n      // No op\n    } else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n      const method = init[Symbol.iterator]; // eslint-disable-next-line no-eq-null, eqeqeq\n\n      if (method == null) {\n        // Record<ByteString, ByteString>\n        result.push(...Object.entries(init));\n      } else {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        } // Sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n\n\n        result = [...init].map(pair => {\n          if (typeof pair !== 'object' || types.isBoxedPrimitive(pair)) {\n            throw new TypeError('Each header pair must be an iterable object');\n          }\n\n          return [...pair];\n        }).map(pair => {\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n\n          return [...pair];\n        });\n      }\n    } else {\n      throw new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n    } // Validate and lowercase\n\n\n    result = result.length > 0 ? result.map(_ref => {\n      let [name, value] = _ref;\n      validateHeaderName(name);\n      validateHeaderValue(name, String(value));\n      return [String(name).toLowerCase(), String(value)];\n    }) : undefined;\n    super(result); // Returning a Proxy that will lowercase key names, validate parameters and sort keys\n    // eslint-disable-next-line no-constructor-return\n\n    return new Proxy(this, {\n      get(target, p, receiver) {\n        switch (p) {\n          case 'append':\n          case 'set':\n            return (name, value) => {\n              validateHeaderName(name);\n              validateHeaderValue(name, String(value));\n              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));\n            };\n\n          case 'delete':\n          case 'has':\n          case 'getAll':\n            return name => {\n              validateHeaderName(name);\n              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());\n            };\n\n          case 'keys':\n            return () => {\n              target.sort();\n              return new Set(URLSearchParams.prototype.keys.call(target)).keys();\n            };\n\n          default:\n            return Reflect.get(target, p, receiver);\n        }\n      }\n\n    });\n    /* c8 ignore next */\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n\n  toString() {\n    return Object.prototype.toString.call(this);\n  }\n\n  get(name) {\n    const values = this.getAll(name);\n\n    if (values.length === 0) {\n      return null;\n    }\n\n    let value = values.join(', ');\n\n    if (/^content-encoding$/i.test(name)) {\n      value = value.toLowerCase();\n    }\n\n    return value;\n  }\n\n  forEach(callback) {\n    let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    for (const name of this.keys()) {\n      Reflect.apply(callback, thisArg, [this.get(name), name, this]);\n    }\n  }\n\n  *values() {\n    for (const name of this.keys()) {\n      yield this.get(name);\n    }\n  }\n  /**\n   * @type {() => IterableIterator<[string, string]>}\n   */\n\n\n  *entries() {\n    for (const name of this.keys()) {\n      yield [name, this.get(name)];\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Node-fetch non-spec method\n   * returning all headers and their values as array\n   * @returns {Record<string, string[]>}\n   */\n\n\n  raw() {\n    return [...this.keys()].reduce((result, key) => {\n      result[key] = this.getAll(key);\n      return result;\n    }, {});\n  }\n  /**\n   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n   */\n\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return [...this.keys()].reduce((result, key) => {\n      const values = this.getAll(key); // Http.request() only supports string as Host header.\n      // This hack makes specifying custom Host header possible.\n\n      if (key === 'host') {\n        result[key] = values[0];\n      } else {\n        result[key] = values.length > 1 ? values : values[0];\n      }\n\n      return result;\n    }, {});\n  }\n\n}\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\n\nObject.defineProperties(Headers.prototype, ['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n  result[property] = {\n    enumerable: true\n  };\n  return result;\n}, {}));\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\n\nexport function fromRawHeaders() {\n  let headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return new Headers(headers // Split into pairs\n  .reduce((result, value, index, array) => {\n    if (index % 2 === 0) {\n      result.push(array.slice(index, index + 2));\n    }\n\n    return result;\n  }, []).filter(_ref2 => {\n    let [name, value] = _ref2;\n\n    try {\n      validateHeaderName(name);\n      validateHeaderValue(name, String(value));\n      return true;\n    } catch {\n      return false;\n    }\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}