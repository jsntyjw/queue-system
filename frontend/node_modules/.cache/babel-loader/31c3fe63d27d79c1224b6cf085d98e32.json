{"ast":null,"code":"import { File } from 'fetch-blob/from.js';\nimport { FormData } from 'formdata-polyfill/esm.min.js';\nlet s = 0;\nconst S = {\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  END: s++\n};\nlet f = 1;\nconst F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n  /**\n   * @param {string} boundary\n   */\n  constructor(boundary) {\n    this.index = 0;\n    this.flags = 0;\n    this.onHeaderEnd = noop;\n    this.onHeaderField = noop;\n    this.onHeadersEnd = noop;\n    this.onHeaderValue = noop;\n    this.onPartBegin = noop;\n    this.onPartData = noop;\n    this.onPartEnd = noop;\n    this.boundaryChars = {};\n    boundary = '\\r\\n--' + boundary;\n    const ui8a = new Uint8Array(boundary.length);\n\n    for (let i = 0; i < boundary.length; i++) {\n      ui8a[i] = boundary.charCodeAt(i);\n      this.boundaryChars[ui8a[i]] = true;\n    }\n\n    this.boundary = ui8a;\n    this.lookbehind = new Uint8Array(this.boundary.length + 8);\n    this.state = S.START_BOUNDARY;\n  }\n  /**\n   * @param {Uint8Array} data\n   */\n\n\n  write(data) {\n    let i = 0;\n    const length_ = data.length;\n    let previousIndex = this.index;\n    let {\n      lookbehind,\n      boundary,\n      boundaryChars,\n      index,\n      state,\n      flags\n    } = this;\n    const boundaryLength = this.boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    const bufferLength = data.length;\n    let c;\n    let cl;\n\n    const mark = name => {\n      this[name + 'Mark'] = i;\n    };\n\n    const clear = name => {\n      delete this[name + 'Mark'];\n    };\n\n    const callback = (callbackSymbol, start, end, ui8a) => {\n      if (start === undefined || start !== end) {\n        this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n      }\n    };\n\n    const dataCallback = (name, clear) => {\n      const markSymbol = name + 'Mark';\n\n      if (!(markSymbol in this)) {\n        return;\n      }\n\n      if (clear) {\n        callback(name, this[markSymbol], i, data);\n        delete this[markSymbol];\n      } else {\n        callback(name, this[markSymbol], data.length, data);\n        this[markSymbol] = 0;\n      }\n    };\n\n    for (i = 0; i < length_; i++) {\n      c = data[i];\n\n      switch (state) {\n        case S.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= F.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              return;\n            }\n\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n              state = S.END;\n              flags = 0;\n            } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              callback('onPartBegin');\n              state = S.HEADER_FIELD_START;\n            } else {\n              return;\n            }\n\n            break;\n          }\n\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n\n          break;\n\n        case S.HEADER_FIELD_START:\n          state = S.HEADER_FIELD;\n          mark('onHeaderField');\n          index = 0;\n        // falls through\n\n        case S.HEADER_FIELD:\n          if (c === CR) {\n            clear('onHeaderField');\n            state = S.HEADERS_ALMOST_DONE;\n            break;\n          }\n\n          index++;\n\n          if (c === HYPHEN) {\n            break;\n          }\n\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              return;\n            }\n\n            dataCallback('onHeaderField', true);\n            state = S.HEADER_VALUE_START;\n            break;\n          }\n\n          cl = lower(c);\n\n          if (cl < A || cl > Z) {\n            return;\n          }\n\n          break;\n\n        case S.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n\n          mark('onHeaderValue');\n          state = S.HEADER_VALUE;\n        // falls through\n\n        case S.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('onHeaderValue', true);\n            callback('onHeaderEnd');\n            state = S.HEADER_VALUE_ALMOST_DONE;\n          }\n\n          break;\n\n        case S.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n\n          state = S.HEADER_FIELD_START;\n          break;\n\n        case S.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n\n          callback('onHeadersEnd');\n          state = S.PART_DATA_START;\n          break;\n\n        case S.PART_DATA_START:\n          state = S.PART_DATA;\n          mark('onPartData');\n        // falls through\n\n        case S.PART_DATA:\n          previousIndex = index;\n\n          if (index === 0) {\n            // boyer-moore derrived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n\n            while (i < bufferLength && !(data[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n\n            i -= boundaryEnd;\n            c = data[i];\n          }\n\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('onPartData', true);\n              }\n\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n\n            if (c === CR) {\n              // CR = part boundary\n              flags |= F.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= F.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & F.PART_BOUNDARY) {\n              index = 0;\n\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~F.PART_BOUNDARY;\n                callback('onPartEnd');\n                callback('onPartBegin');\n                state = S.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & F.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                callback('onPartEnd');\n                state = S.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (previousIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\n            callback('onPartData', 0, previousIndex, _lookbehind);\n            previousIndex = 0;\n            mark('onPartData'); // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n\n            i--;\n          }\n\n          break;\n\n        case S.END:\n          break;\n\n        default:\n          throw new Error(`Unexpected state entered: ${state}`);\n      }\n    }\n\n    dataCallback('onHeaderField');\n    dataCallback('onHeaderValue');\n    dataCallback('onPartData'); // Update properties for the next call\n\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n  }\n\n  end() {\n    if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n      this.onPartEnd();\n    } else if (this.state !== S.END) {\n      throw new Error('MultipartParser.end(): stream ended unexpectedly');\n    }\n  }\n\n}\n\nfunction _fileName(headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\n  if (!m) {\n    return;\n  }\n\n  const match = m[2] || m[3] || '';\n  let filename = match.slice(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\n\nexport async function toFormData(Body, ct) {\n  if (!/multipart/i.test(ct)) {\n    throw new TypeError('Failed to fetch');\n  }\n\n  const m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n  if (!m) {\n    throw new TypeError('no or bad content-type header, no multipart boundary');\n  }\n\n  const parser = new MultipartParser(m[1] || m[2]);\n  let headerField;\n  let headerValue;\n  let entryValue;\n  let entryName;\n  let contentType;\n  let filename;\n  const entryChunks = [];\n  const formData = new FormData();\n\n  const onPartData = ui8a => {\n    entryValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n\n  const appendToFile = ui8a => {\n    entryChunks.push(ui8a);\n  };\n\n  const appendFileToFormData = () => {\n    const file = new File(entryChunks, filename, {\n      type: contentType\n    });\n    formData.append(entryName, file);\n  };\n\n  const appendEntryToFormData = () => {\n    formData.append(entryName, entryValue);\n  };\n\n  const decoder = new TextDecoder('utf-8');\n  decoder.decode();\n\n  parser.onPartBegin = function () {\n    parser.onPartData = onPartData;\n    parser.onPartEnd = appendEntryToFormData;\n    headerField = '';\n    headerValue = '';\n    entryValue = '';\n    entryName = '';\n    contentType = '';\n    filename = null;\n    entryChunks.length = 0;\n  };\n\n  parser.onHeaderField = function (ui8a) {\n    headerField += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n\n  parser.onHeaderValue = function (ui8a) {\n    headerValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n\n  parser.onHeaderEnd = function () {\n    headerValue += decoder.decode();\n    headerField = headerField.toLowerCase();\n\n    if (headerField === 'content-disposition') {\n      // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n      const m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n      if (m) {\n        entryName = m[2] || m[3] || '';\n      }\n\n      filename = _fileName(headerValue);\n\n      if (filename) {\n        parser.onPartData = appendToFile;\n        parser.onPartEnd = appendFileToFormData;\n      }\n    } else if (headerField === 'content-type') {\n      contentType = headerValue;\n    }\n\n    headerValue = '';\n    headerField = '';\n  };\n\n  for await (const chunk of Body) {\n    parser.write(chunk);\n  }\n\n  parser.end();\n  return formData;\n}","map":null,"metadata":{},"sourceType":"module"}