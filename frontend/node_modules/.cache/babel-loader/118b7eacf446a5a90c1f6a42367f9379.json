{"ast":null,"code":"/// !-----------------------------------------------------------------------------------------------------------\n/// |  \n//  |  `digest-fetch` is a wrapper of `node-fetch` or `fetch` to provide http digest authentication boostraping.\n//  |\n/// !-----------------------------------------------------------------------------------------------------------\nconst canRequire = typeof require == 'function';\nif (typeof fetch !== 'function' && canRequire) var fetch = require('node-fetch');\n\nconst md5 = require('md5');\n\nconst base64 = require('base-64');\n\nconst supported_algorithms = ['MD5', 'MD5-sess'];\n\nconst parse = function (raw, field) {\n  let trim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const regex = new RegExp(`${field}=(\"[^\"]*\"|[^,]*)`, \"i\");\n  const match = regex.exec(raw);\n  if (match) return trim ? match[1].replace(/[\\s\"]/g, '') : match[1];\n  return null;\n};\n\nclass DigestClient {\n  constructor(user, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.user = user;\n    this.password = password;\n    this.nonceRaw = 'abcdef0123456789';\n    this.logger = options.logger;\n    this.precomputedHash = options.precomputedHash;\n    let algorithm = options.algorithm || 'MD5';\n\n    if (!supported_algorithms.includes(algorithm)) {\n      if (this.logger) this.logger.warn(`Unsupported algorithm ${algorithm}, will try with MD5`);\n      algorithm = 'MD5';\n    }\n\n    this.digest = {\n      nc: 0,\n      algorithm,\n      realm: ''\n    };\n    this.hasAuth = false;\n\n    const _cnonceSize = parseInt(options.cnonceSize);\n\n    this.cnonceSize = isNaN(_cnonceSize) ? 32 : _cnonceSize; // cnonce length 32 as default\n    // Custom authentication failure code for avoiding browser prompt:\n    // https://stackoverflow.com/questions/9859627/how-to-prevent-browser-to-invoke-basic-auth-popup-and-handle-401-error-using-jqu\n\n    this.statusCode = options.statusCode;\n    this.basic = options.basic || false;\n  }\n\n  async fetch(url) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.basic) return fetch(url, this.addBasicAuth(options));\n    const resp = await fetch(url, this.addAuth(url, options));\n\n    if (resp.status == 401 || resp.status == this.statusCode && this.statusCode) {\n      this.hasAuth = false;\n      await this.parseAuth(resp.headers.get('www-authenticate'));\n\n      if (this.hasAuth) {\n        const respFinal = await fetch(url, this.addAuth(url, options));\n\n        if (respFinal.status == 401 || respFinal.status == this.statusCode) {\n          this.hasAuth = false;\n        } else {\n          this.digest.nc++;\n        }\n\n        return respFinal;\n      }\n    } else this.digest.nc++;\n\n    return resp;\n  }\n\n  addBasicAuth() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let _options = {};\n\n    if (typeof options.factory == 'function') {\n      _options = options.factory();\n    } else {\n      _options = options;\n    }\n\n    const auth = 'Basic ' + base64.encode(this.user + \":\" + this.password);\n    _options.headers = _options.headers || {};\n    _options.headers.Authorization = auth;\n\n    if (typeof _options.headers.set == 'function') {\n      _options.headers.set('Authorization', auth);\n    }\n\n    if (this.logger) this.logger.debug(options);\n    return _options;\n  }\n\n  static computeHash(user, realm, password) {\n    return md5(`${user}:${realm}:${password}`);\n  }\n\n  addAuth(url, options) {\n    if (typeof options.factory == 'function') options = options.factory();\n    if (!this.hasAuth) return options;\n    if (this.logger) this.logger.info(`requesting with auth carried`);\n    const isRequest = typeof url === 'object' && typeof url.url === 'string';\n    const urlStr = isRequest ? url.url : url;\n\n    const _url = urlStr.replace('//', '');\n\n    const uri = _url.indexOf('/') == -1 ? '/' : _url.slice(_url.indexOf('/'));\n    const method = options.method ? options.method.toUpperCase() : 'GET';\n    let ha1 = this.precomputedHash ? this.password : DigestClient.computeHash(this.user, this.digest.realm, this.password);\n\n    if (this.digest.algorithm === 'MD5-sess') {\n      ha1 = md5(`${ha1}:${this.digest.nonce}:${this.digest.cnonce}`);\n    } // optional MD5(entityBody) for 'auth-int'\n\n\n    let _ha2 = '';\n\n    if (this.digest.qop === 'auth-int') {\n      // not implemented for auth-int\n      if (this.logger) this.logger.warn('Sorry, auth-int is not implemented in this plugin'); // const entityBody = xxx\n      // _ha2 = ':' + md5(entityBody)\n    }\n\n    const ha2 = md5(`${method}:${uri}${_ha2}`);\n    const ncString = ('00000000' + this.digest.nc).slice(-8);\n    let _response = `${ha1}:${this.digest.nonce}:${ncString}:${this.digest.cnonce}:${this.digest.qop}:${ha2}`;\n    if (!this.digest.qop) _response = `${ha1}:${this.digest.nonce}:${ha2}`;\n    const response = md5(_response);\n    const opaqueString = this.digest.opaque !== null ? `opaque=\"${this.digest.opaque}\",` : '';\n    const qopString = this.digest.qop ? `qop=\"${this.digest.qop}\",` : '';\n    const digest = `${this.digest.scheme} username=\"${this.user}\",realm=\"${this.digest.realm}\",\\\nnonce=\"${this.digest.nonce}\",uri=\"${uri}\",${opaqueString}${qopString}\\\nalgorithm=\"${this.digest.algorithm}\",response=\"${response}\",nc=${ncString},cnonce=\"${this.digest.cnonce}\"`;\n    options.headers = options.headers || {};\n    options.headers.Authorization = digest;\n\n    if (typeof options.headers.set == 'function') {\n      options.headers.set('Authorization', digest);\n    }\n\n    if (this.logger) this.logger.debug(options); // const {factory, ..._options} = options\n\n    const _options = {};\n    Object.assign(_options, options);\n    delete _options.factory;\n    return _options;\n  }\n\n  async parseAuth(h) {\n    this.lastAuth = h;\n\n    if (!h || h.length < 5) {\n      this.hasAuth = false;\n      return;\n    }\n\n    this.hasAuth = true;\n    this.digest.scheme = h.split(/\\s/)[0];\n    this.digest.realm = (parse(h, 'realm', false) || '').replace(/[\"]/g, '');\n    this.digest.qop = this.parseQop(h);\n    this.digest.opaque = parse(h, 'opaque');\n    this.digest.nonce = parse(h, 'nonce') || '';\n    this.digest.cnonce = this.makeNonce();\n    this.digest.nc++;\n  }\n\n  parseQop(rawAuth) {\n    // Following https://en.wikipedia.org/wiki/Digest_access_authentication\n    // to parse valid qop\n    // Samples \n    // : qop=\"auth,auth-init\",realm=\n    // : qop=auth,realm=\n    const _qop = parse(rawAuth, 'qop');\n\n    if (_qop !== null) {\n      const qops = _qop.split(',');\n\n      if (qops.includes('auth')) return 'auth';else if (qops.includes('auth-int')) return 'auth-int';\n    } // when not specified\n\n\n    return null;\n  }\n\n  makeNonce() {\n    let uid = '';\n\n    for (let i = 0; i < this.cnonceSize; ++i) {\n      uid += this.nonceRaw[Math.floor(Math.random() * this.nonceRaw.length)];\n    }\n\n    return uid;\n  }\n\n  static parse() {\n    return parse(...arguments);\n  }\n\n}\n\nif (typeof window === \"object\") window.DigestFetch = DigestClient;\nmodule.exports = DigestClient;","map":null,"metadata":{},"sourceType":"script"}