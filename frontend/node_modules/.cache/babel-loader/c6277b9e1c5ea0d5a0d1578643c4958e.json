{"ast":null,"code":"import { isIP } from 'node:net';\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */\n\n/**\n * @module utils/referrer\n * @private\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */\n\nexport function stripURLForUseAsAReferrer(url) {\n  let originOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // 1. If url is null, return no referrer.\n  if (url == null) {\n    // eslint-disable-line no-eq-null, eqeqeq\n    return 'no-referrer';\n  }\n\n  url = new URL(url); // 2. If url's scheme is a local scheme, then return no referrer.\n\n  if (/^(about|blob|data):$/.test(url.protocol)) {\n    return 'no-referrer';\n  } // 3. Set url's username to the empty string.\n\n\n  url.username = ''; // 4. Set url's password to null.\n  // Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n\n  url.password = ''; // 5. Set url's fragment to null.\n  // Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n\n  url.hash = ''; // 6. If the origin-only flag is true, then:\n\n  if (originOnly) {\n    // 6.1. Set url's path to null.\n    // Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n    url.pathname = ''; // 6.2. Set url's query to null.\n    // Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n\n    url.search = '';\n  } // 7. Return url.\n\n\n  return url;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */\n\nexport const ReferrerPolicy = new Set(['', 'no-referrer', 'no-referrer-when-downgrade', 'same-origin', 'origin', 'strict-origin', 'origin-when-cross-origin', 'strict-origin-when-cross-origin', 'unsafe-url']);\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */\n\nexport const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */\n\nexport function validateReferrerPolicy(referrerPolicy) {\n  if (!ReferrerPolicy.has(referrerPolicy)) {\n    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n  }\n\n  return referrerPolicy;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\n\nexport function isOriginPotentiallyTrustworthy(url) {\n  // 1. If origin is an opaque origin, return \"Not Trustworthy\".\n  // Not applicable\n  // 2. Assert: origin is a tuple origin.\n  // Not for implementations\n  // 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n  if (/^(http|ws)s:$/.test(url.protocol)) {\n    return true;\n  } // 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n\n\n  const hostIp = url.host.replace(/(^\\[)|(]$)/g, '');\n  const hostIPVersion = isIP(hostIp);\n\n  if (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n    return true;\n  }\n\n  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n    return true;\n  } // 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n  // We are returning FALSE here because we cannot ensure conformance to\n  // let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n\n\n  if (/^(.+\\.)*localhost$/.test(url.host)) {\n    return false;\n  } // 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n\n\n  if (url.protocol === 'file:') {\n    return true;\n  } // 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n  // Not supported\n  // 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n  // Not supported\n  // 9. Return \"Not Trustworthy\".\n\n\n  return false;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\n\nexport function isUrlPotentiallyTrustworthy(url) {\n  // 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n  if (/^about:(blank|srcdoc)$/.test(url)) {\n    return true;\n  } // 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n\n\n  if (url.protocol === 'data:') {\n    return true;\n  } // Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n  // created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n  // trustworthy.\n\n\n  if (/^(blob|filesystem):$/.test(url.protocol)) {\n    return true;\n  } // 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.\n\n\n  return isOriginPotentiallyTrustworthy(url);\n}\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */\n\n/**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */\n\nexport function determineRequestsReferrer(request) {\n  let {\n    referrerURLCallback,\n    referrerOriginCallback\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n  // these cases:\n  // > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n  // > Note: If request's referrer policy is the empty string, Fetch will not call into this\n  // > algorithm.\n  if (request.referrer === 'no-referrer' || request.referrerPolicy === '') {\n    return null;\n  } // 1. Let policy be request's associated referrer policy.\n\n\n  const policy = request.referrerPolicy; // 2. Let environment be request's client.\n  // not applicable to node.js\n  // 3. Switch on request's referrer:\n\n  if (request.referrer === 'about:client') {\n    return 'no-referrer';\n  } // \"a URL\": Let referrerSource be request's referrer.\n\n\n  const referrerSource = request.referrer; // 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n\n  let referrerURL = stripURLForUseAsAReferrer(referrerSource); // 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n  //    origin-only flag set to true.\n\n  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true); // 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n  //    referrerURL to referrerOrigin.\n\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin;\n  } // 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n  //    policy considerations in the interests of minimizing data leakage. For example, the user\n  //    agent could strip the URL down to an origin, modify its host, replace it with an empty\n  //    string, etc.\n\n\n  if (referrerURLCallback) {\n    referrerURL = referrerURLCallback(referrerURL);\n  }\n\n  if (referrerOriginCallback) {\n    referrerOrigin = referrerOriginCallback(referrerOrigin);\n  } // 8.Execute the statements corresponding to the value of policy:\n\n\n  const currentURL = new URL(request.url);\n\n  switch (policy) {\n    case 'no-referrer':\n      return 'no-referrer';\n\n    case 'origin':\n      return referrerOrigin;\n\n    case 'unsafe-url':\n      return referrerURL;\n\n    case 'strict-origin':\n      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n      //    potentially trustworthy URL, then return no referrer.\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer';\n      } // 2. Return referrerOrigin.\n\n\n      return referrerOrigin.toString();\n\n    case 'strict-origin-when-cross-origin':\n      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n      //    return referrerURL.\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      } // 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n      //    potentially trustworthy URL, then return no referrer.\n\n\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer';\n      } // 3. Return referrerOrigin.\n\n\n      return referrerOrigin;\n\n    case 'same-origin':\n      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n      //    return referrerURL.\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      } // 2. Return no referrer.\n\n\n      return 'no-referrer';\n\n    case 'origin-when-cross-origin':\n      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n      //    return referrerURL.\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      } // Return referrerOrigin.\n\n\n      return referrerOrigin;\n\n    case 'no-referrer-when-downgrade':\n      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n      //    potentially trustworthy URL, then return no referrer.\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer';\n      } // 2. Return referrerURL.\n\n\n      return referrerURL;\n\n    default:\n      throw new TypeError(`Invalid referrerPolicy: ${policy}`);\n  }\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */\n\nexport function parseReferrerPolicyFromHeader(headers) {\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n  //    and response’s header list.\n  const policyTokens = (headers.get('referrer-policy') || '').split(/[,\\s]+/); // 2. Let policy be the empty string.\n\n  let policy = ''; // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n  //    string, then set policy to token.\n  // Note: This algorithm loops over multiple policy values to allow deployment of new policy\n  // values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.\n\n  for (const token of policyTokens) {\n    if (token && ReferrerPolicy.has(token)) {\n      policy = token;\n    }\n  } // 4. Return policy.\n\n\n  return policy;\n}","map":null,"metadata":{},"sourceType":"module"}