{"ast":null,"code":"/*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\nimport C from 'fetch-blob';\nimport F from 'fetch-blob/file.js';\n\nvar {\n  toStringTag: t,\n  iterator: i,\n  hasInstance: h\n} = Symbol,\n    r = Math.random,\n    m = 'append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),\n    f = (a, b, c) => (a += '', /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + '' : b[t] == 'File' ? b.name : 'blob', a), b.name !== c || b[t] == 'blob' ? new F([b], c, b) : b] : [a, b + '']),\n    e = (c, f) => (f ? c : c.replace(/\\r?\\n|\\r/g, '\\r\\n')).replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22'),\n    x = (n, a, e) => {\n  if (a.length < e) {\n    throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);\n  }\n};\n\nexport const File = F;\n/** @type {typeof globalThis.FormData} */\n\nexport const FormData = class FormData {\n  #d = [];\n\n  constructor() {\n    if (arguments.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);\n  }\n\n  get [t]() {\n    return 'FormData';\n  }\n\n  [i]() {\n    return this.entries();\n  }\n\n  static [h](o) {\n    return o && typeof o === 'object' && o[t] === 'FormData' && !m.some(m => typeof o[m] != 'function');\n  }\n\n  append() {\n    for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n      a[_key] = arguments[_key];\n    }\n\n    x('append', arguments, 2);\n    this.#d.push(f(...a));\n  }\n\n  delete(a) {\n    x('delete', arguments, 1);\n    a += '';\n    this.#d = this.#d.filter(_ref => {\n      let [b] = _ref;\n      return b !== a;\n    });\n  }\n\n  get(a) {\n    x('get', arguments, 1);\n    a += '';\n\n    for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];\n\n    return null;\n  }\n\n  getAll(a, b) {\n    x('getAll', arguments, 1);\n    b = [];\n    a += '';\n    this.#d.forEach(c => c[0] === a && b.push(c[1]));\n    return b;\n  }\n\n  has(a) {\n    x('has', arguments, 1);\n    a += '';\n    return this.#d.some(b => b[0] === a);\n  }\n\n  forEach(a, b) {\n    x('forEach', arguments, 1);\n\n    for (var [c, d] of this) a.call(b, d, c, this);\n  }\n\n  set() {\n    for (var _len2 = arguments.length, a = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      a[_key2] = arguments[_key2];\n    }\n\n    x('set', arguments, 2);\n    var b = [],\n        c = !0;\n    a = f(...a);\n    this.#d.forEach(d => {\n      d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);\n    });\n    c && b.push(a);\n    this.#d = b;\n  }\n\n  *entries() {\n    yield* this.#d;\n  }\n\n  *keys() {\n    for (var [a] of this) yield a;\n  }\n\n  *values() {\n    for (var [, a] of this) yield a;\n  }\n\n};\n/** @param {FormData} F */\n\nexport function formDataToBlob(F) {\n  let B = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : C;\n  var b = `${r()}${r()}`.replace(/\\./g, '').slice(-28).padStart(32, '-'),\n      c = [],\n      p = `--${b}\\r\\nContent-Disposition: form-data; name=\"`;\n  F.forEach((v, n) => typeof v == 'string' ? c.push(p + e(n) + `\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, '\\r\\n')}\\r\\n`) : c.push(p + e(n) + `\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type || \"application/octet-stream\"}\\r\\n\\r\\n`, v, '\\r\\n'));\n  c.push(`--${b}--`);\n  return new B(c, {\n    type: \"multipart/form-data; boundary=\" + b\n  });\n}","map":null,"metadata":{},"sourceType":"module"}