{"ast":null,"code":"/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\nimport Stream, { PassThrough } from 'node:stream';\nimport { types, deprecate, promisify } from 'node:util';\nimport { Buffer } from 'node:buffer';\nimport Blob from 'fetch-blob';\nimport { FormData, formDataToBlob } from 'formdata-polyfill/esm.min.js';\nimport { FetchError } from './errors/fetch-error.js';\nimport { FetchBaseError } from './errors/base.js';\nimport { isBlob, isURLSearchParameters } from './utils/is.js';\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\n\nexport default class Body {\n  constructor(body) {\n    let {\n      size = 0\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let boundary = null;\n\n    if (body === null) {\n      // Body is undefined or null\n      body = null;\n    } else if (isURLSearchParameters(body)) {\n      // Body is a URLSearchParams\n      body = Buffer.from(body.toString());\n    } else if (isBlob(body)) {// Body is blob\n    } else if (Buffer.isBuffer(body)) {// Body is Buffer\n    } else if (types.isAnyArrayBuffer(body)) {\n      // Body is ArrayBuffer\n      body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n      // Body is ArrayBufferView\n      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof Stream) {// Body is stream\n    } else if (body instanceof FormData) {\n      // Body is FormData\n      body = formDataToBlob(body);\n      boundary = body.type.split('=')[1];\n    } else {\n      // None of the above\n      // coerce to string then buffer\n      body = Buffer.from(String(body));\n    }\n\n    let stream = body;\n\n    if (Buffer.isBuffer(body)) {\n      stream = Stream.Readable.from(body);\n    } else if (isBlob(body)) {\n      stream = Stream.Readable.from(body.stream());\n    }\n\n    this[INTERNALS] = {\n      body,\n      stream,\n      boundary,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n\n    if (body instanceof Stream) {\n      body.on('error', error_ => {\n        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n\n  get body() {\n    return this[INTERNALS].stream;\n  }\n\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n\n\n  async arrayBuffer() {\n    const {\n      buffer,\n      byteOffset,\n      byteLength\n    } = await consumeBody(this);\n    return buffer.slice(byteOffset, byteOffset + byteLength);\n  }\n\n  async formData() {\n    const ct = this.headers.get('content-type');\n\n    if (ct.startsWith('application/x-www-form-urlencoded')) {\n      const formData = new FormData();\n      const parameters = new URLSearchParams(await this.text());\n\n      for (const [name, value] of parameters) {\n        formData.append(name, value);\n      }\n\n      return formData;\n    }\n\n    const {\n      toFormData\n    } = await import('./utils/multipart-parser.js');\n    return toFormData(this.body, ct);\n  }\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n\n\n  async blob() {\n    const ct = this.headers && this.headers.get('content-type') || this[INTERNALS].body && this[INTERNALS].body.type || '';\n    const buf = await this.arrayBuffer();\n    return new Blob([buf], {\n      type: ct\n    });\n  }\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n\n\n  async json() {\n    const buffer = await consumeBody(this);\n    return JSON.parse(buffer.toString());\n  }\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n\n\n  async text() {\n    const buffer = await consumeBody(this);\n    return buffer.toString();\n  }\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n\n\n  buffer() {\n    return consumeBody(this);\n  }\n\n}\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer'); // In browsers, all properties are enumerable.\n\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  },\n  data: {\n    get: deprecate(() => {}, 'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (response)')\n  }\n});\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\n\nasync function consumeBody(data) {\n  if (data[INTERNALS].disturbed) {\n    throw new TypeError(`body used already for: ${data.url}`);\n  }\n\n  data[INTERNALS].disturbed = true;\n\n  if (data[INTERNALS].error) {\n    throw data[INTERNALS].error;\n  }\n\n  const {\n    body\n  } = data; // Body is null\n\n  if (body === null) {\n    return Buffer.alloc(0);\n  }\n  /* c8 ignore next 3 */\n\n\n  if (!(body instanceof Stream)) {\n    return Buffer.alloc(0);\n  } // Body is stream\n  // get ready to actually consume the body\n\n\n  const accum = [];\n  let accumBytes = 0;\n\n  try {\n    for await (const chunk of body) {\n      if (data.size > 0 && accumBytes + chunk.length > data.size) {\n        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n        body.destroy(error);\n        throw error;\n      }\n\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    }\n  } catch (error) {\n    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n    throw error_;\n  }\n\n  if (body.readableEnded === true || body._readableState.ended === true) {\n    try {\n      if (accum.every(c => typeof c === 'string')) {\n        return Buffer.from(accum.join(''));\n      }\n\n      return Buffer.concat(accum, accumBytes);\n    } catch (error) {\n      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n    }\n  } else {\n    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n  }\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\n\n\nexport const clone = (instance, highWaterMark) => {\n  let p1;\n  let p2;\n  let {\n    body\n  } = instance[INTERNALS]; // Don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // Check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // Tee instance body\n    p1 = new PassThrough({\n      highWaterMark\n    });\n    p2 = new PassThrough({\n      highWaterMark\n    });\n    body.pipe(p1);\n    body.pipe(p2); // Set instance body to teed body and return the other teed body\n\n    instance[INTERNALS].stream = p1;\n    body = p2;\n  }\n\n  return body;\n};\nconst getNonSpecFormDataBoundary = deprecate(body => body.getBoundary(), 'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package', 'https://github.com/node-fetch/node-fetch/issues/1167');\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\n\nexport const extractContentType = (body, request) => {\n  // Body is null or undefined\n  if (body === null) {\n    return null;\n  } // Body is string\n\n\n  if (typeof body === 'string') {\n    return 'text/plain;charset=UTF-8';\n  } // Body is a URLSearchParams\n\n\n  if (isURLSearchParameters(body)) {\n    return 'application/x-www-form-urlencoded;charset=UTF-8';\n  } // Body is blob\n\n\n  if (isBlob(body)) {\n    return body.type || null;\n  } // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\n\n  if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n    return null;\n  }\n\n  if (body instanceof FormData) {\n    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getBoundary === 'function') {\n    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n  } // Body is stream - can't really do much about this\n\n\n  if (body instanceof Stream) {\n    return null;\n  } // Body constructor defaults other things to string\n\n\n  return 'text/plain;charset=UTF-8';\n};\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\n\nexport const getTotalBytes = request => {\n  const {\n    body\n  } = request[INTERNALS]; // Body is null or undefined\n\n  if (body === null) {\n    return 0;\n  } // Body is Blob\n\n\n  if (isBlob(body)) {\n    return body.size;\n  } // Body is Buffer\n\n\n  if (Buffer.isBuffer(body)) {\n    return body.length;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getLengthSync === 'function') {\n    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n  } // Body is stream\n\n\n  return null;\n};\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\n\nexport const writeToStream = async (dest, _ref) => {\n  let {\n    body\n  } = _ref;\n\n  if (body === null) {\n    // Body is null\n    dest.end();\n  } else {\n    // Body is stream\n    await pipeline(body, dest);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}