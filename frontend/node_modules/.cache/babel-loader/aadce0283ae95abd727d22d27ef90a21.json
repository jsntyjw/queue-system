{"ast":null,"code":"/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\nimport { format as formatUrl } from 'node:url';\nimport { deprecate } from 'node:util';\nimport Headers from './headers.js';\nimport Body, { clone, extractContentType, getTotalBytes } from './body.js';\nimport { isAbortSignal } from './utils/is.js';\nimport { getSearch } from './utils/get-search.js';\nimport { validateReferrerPolicy, determineRequestsReferrer, DEFAULT_REFERRER_POLICY } from './utils/referrer.js';\nconst INTERNALS = Symbol('Request internals');\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} object\n * @return {boolean}\n */\n\nconst isRequest = object => {\n  return typeof object === 'object' && typeof object[INTERNALS] === 'object';\n};\n\nconst doBadDataWarn = deprecate(() => {}, '.data is not a valid RequestInit property, use .body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (request)');\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\n\nexport default class Request extends Body {\n  constructor(input) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parsedURL; // Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n\n    if (isRequest(input)) {\n      parsedURL = new URL(input.url);\n    } else {\n      parsedURL = new URL(input);\n      input = {};\n    }\n\n    if (parsedURL.username !== '' || parsedURL.password !== '') {\n      throw new TypeError(`${parsedURL} is an url with embedded credentails.`);\n    }\n\n    let method = init.method || input.method || 'GET';\n    method = method.toUpperCase();\n\n    if ('data' in init) {\n      doBadDataWarn();\n    } // eslint-disable-next-line no-eq-null, eqeqeq\n\n\n    if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n      throw new TypeError('Request with GET/HEAD method cannot have body');\n    }\n\n    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n    super(inputBody, {\n      size: init.size || input.size || 0\n    });\n    const headers = new Headers(init.headers || input.headers || {});\n\n    if (inputBody !== null && !headers.has('Content-Type')) {\n      const contentType = extractContentType(inputBody, this);\n\n      if (contentType) {\n        headers.set('Content-Type', contentType);\n      }\n    }\n\n    let signal = isRequest(input) ? input.signal : null;\n\n    if ('signal' in init) {\n      signal = init.signal;\n    } // eslint-disable-next-line no-eq-null, eqeqeq\n\n\n    if (signal != null && !isAbortSignal(signal)) {\n      throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');\n    } // §5.4, Request constructor steps, step 15.1\n    // eslint-disable-next-line no-eq-null, eqeqeq\n\n\n    let referrer = init.referrer == null ? input.referrer : init.referrer;\n\n    if (referrer === '') {\n      // §5.4, Request constructor steps, step 15.2\n      referrer = 'no-referrer';\n    } else if (referrer) {\n      // §5.4, Request constructor steps, step 15.3.1, 15.3.2\n      const parsedReferrer = new URL(referrer); // §5.4, Request constructor steps, step 15.3.3, 15.3.4\n\n      referrer = /^about:(\\/\\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;\n    } else {\n      referrer = undefined;\n    }\n\n    this[INTERNALS] = {\n      method,\n      redirect: init.redirect || input.redirect || 'follow',\n      headers,\n      parsedURL,\n      signal,\n      referrer\n    }; // Node-fetch-only options\n\n    this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;\n    this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;\n    this.counter = init.counter || input.counter || 0;\n    this.agent = init.agent || input.agent;\n    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false; // §5.4, Request constructor steps, step 16.\n    // Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy\n\n    this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';\n  }\n  /** @returns {string} */\n\n\n  get method() {\n    return this[INTERNALS].method;\n  }\n  /** @returns {string} */\n\n\n  get url() {\n    return formatUrl(this[INTERNALS].parsedURL);\n  }\n  /** @returns {Headers} */\n\n\n  get headers() {\n    return this[INTERNALS].headers;\n  }\n\n  get redirect() {\n    return this[INTERNALS].redirect;\n  }\n  /** @returns {AbortSignal} */\n\n\n  get signal() {\n    return this[INTERNALS].signal;\n  } // https://fetch.spec.whatwg.org/#dom-request-referrer\n\n\n  get referrer() {\n    if (this[INTERNALS].referrer === 'no-referrer') {\n      return '';\n    }\n\n    if (this[INTERNALS].referrer === 'client') {\n      return 'about:client';\n    }\n\n    if (this[INTERNALS].referrer) {\n      return this[INTERNALS].referrer.toString();\n    }\n\n    return undefined;\n  }\n\n  get referrerPolicy() {\n    return this[INTERNALS].referrerPolicy;\n  }\n\n  set referrerPolicy(referrerPolicy) {\n    this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);\n  }\n  /**\n   * Clone this request\n   *\n   * @return  Request\n   */\n\n\n  clone() {\n    return new Request(this);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Request';\n  }\n\n}\nObject.defineProperties(Request.prototype, {\n  method: {\n    enumerable: true\n  },\n  url: {\n    enumerable: true\n  },\n  headers: {\n    enumerable: true\n  },\n  redirect: {\n    enumerable: true\n  },\n  clone: {\n    enumerable: true\n  },\n  signal: {\n    enumerable: true\n  },\n  referrer: {\n    enumerable: true\n  },\n  referrerPolicy: {\n    enumerable: true\n  }\n});\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param {Request} request - A Request instance\n * @return The options object to be passed to http.request\n */\n\nexport const getNodeRequestOptions = request => {\n  const {\n    parsedURL\n  } = request[INTERNALS];\n  const headers = new Headers(request[INTERNALS].headers); // Fetch step 1.3\n\n  if (!headers.has('Accept')) {\n    headers.set('Accept', '*/*');\n  } // HTTP-network-or-cache fetch steps 2.4-2.7\n\n\n  let contentLengthValue = null;\n\n  if (request.body === null && /^(post|put)$/i.test(request.method)) {\n    contentLengthValue = '0';\n  }\n\n  if (request.body !== null) {\n    const totalBytes = getTotalBytes(request); // Set Content-Length if totalBytes is a number (that is not NaN)\n\n    if (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {\n      contentLengthValue = String(totalBytes);\n    }\n  }\n\n  if (contentLengthValue) {\n    headers.set('Content-Length', contentLengthValue);\n  } // 4.1. Main fetch, step 2.6\n  // > If request's referrer policy is the empty string, then set request's referrer policy to the\n  // > default referrer policy.\n\n\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = DEFAULT_REFERRER_POLICY;\n  } // 4.1. Main fetch, step 2.7\n  // > If request's referrer is not \"no-referrer\", set request's referrer to the result of invoking\n  // > determine request's referrer.\n\n\n  if (request.referrer && request.referrer !== 'no-referrer') {\n    request[INTERNALS].referrer = determineRequestsReferrer(request);\n  } else {\n    request[INTERNALS].referrer = 'no-referrer';\n  } // 4.5. HTTP-network-or-cache fetch, step 6.9\n  // > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized\n  // >  and isomorphic encoded, to httpRequest's header list.\n\n\n  if (request[INTERNALS].referrer instanceof URL) {\n    headers.set('Referer', request.referrer);\n  } // HTTP-network-or-cache fetch step 2.11\n\n\n  if (!headers.has('User-Agent')) {\n    headers.set('User-Agent', 'node-fetch');\n  } // HTTP-network-or-cache fetch step 2.15\n\n\n  if (request.compress && !headers.has('Accept-Encoding')) {\n    headers.set('Accept-Encoding', 'gzip,deflate,br');\n  }\n\n  let {\n    agent\n  } = request;\n\n  if (typeof agent === 'function') {\n    agent = agent(parsedURL);\n  }\n\n  if (!headers.has('Connection') && !agent) {\n    headers.set('Connection', 'close');\n  } // HTTP-network fetch step 4.2\n  // chunked encoding is handled by Node.js\n\n\n  const search = getSearch(parsedURL); // Pass the full URL directly to request(), but overwrite the following\n  // options:\n\n  const options = {\n    // Overwrite search to retain trailing ? (issue #776)\n    path: parsedURL.pathname + search,\n    // The following options are not expressed in the URL\n    method: request.method,\n    headers: headers[Symbol.for('nodejs.util.inspect.custom')](),\n    insecureHTTPParser: request.insecureHTTPParser,\n    agent\n  };\n  return {\n    /** @type {URL} */\n    parsedURL,\n    options\n  };\n};","map":null,"metadata":{},"sourceType":"module"}